import os
import base64
import re
from dotenv import load_dotenv
from ic.canister import Canister
from ic.client import Client
from ic.identity import Identity
from ic.agent import Agent as ICAgent
from ic.principal import Principal
from cryptography.hazmat.primitives.serialization import load_pem_private_key, load_der_private_key, Encoding, PrivateFormat, NoEncryption
from cryptography.hazmat.primitives.asymmetric import ed25519, ec

load_dotenv()

BASE_URL = "http://localhost:4943" if os.getenv("DFX_NETWORK") == "local" else "https://ic0.app"

client = Client(url=BASE_URL)

def _get_candid_path(canister_name: str) -> str:
    # For wallet, prefer the source DID generated by build (kept freshest)
    if canister_name == "wallet":
        src_did = "../src/wallet/wallet.did"
        if os.path.isfile(src_did):
            return src_did
    # Otherwise, use declarations path if present (dfx generate)
    decl_path = f"../src/declarations/{canister_name}/{canister_name}.did"
    if os.path.isfile(decl_path):
        return decl_path
    # Fallback to source DID if exists for any other canister naming
    generic_src = f"../src/{canister_name}/{canister_name}.did"
    if os.path.isfile(generic_src):
        return generic_src
    # Default to declarations path (may raise later if missing)
    return decl_path


def _normalize_privkey_to_hex(priv_key: str) -> str:
    """Accept private key in forms of:
    - hex (direct)
    - PEM (with header) PKCS8
    - base64 body from PEM PKCS8 (without header)
    and return 32-byte hex (Ed25519 Raw).
    """
    s = (priv_key or "").strip()
    # If already a valid hex
    if re.fullmatch(r"[0-9a-fA-F]+", s) and len(s) % 2 == 0:
        return s.lower()
    # If the string contains a PEM header
    if "-----BEGIN" in s:
        key = load_pem_private_key(s.encode("utf-8"), password=None)
        # Ed25519 private key: export raw 32 bytes
        if isinstance(key, ed25519.Ed25519PrivateKey):
            raw = key.private_bytes(Encoding.Raw, PrivateFormat.Raw, NoEncryption())
            return raw.hex()
        # EC private key (e.g., "BEGIN EC PRIVATE KEY"): derive integer d then 32-byte big-endian
        if isinstance(key, ec.EllipticCurvePrivateKey):
            d = key.private_numbers().private_value
            # 32 bytes for P-256/secp256k1; pad as needed
            raw32 = d.to_bytes(32, byteorder="big", signed=False)
            return raw32.hex()
        # Other key types unsupported
        raise ValueError("Unsupported PEM key type. Provide Ed25519 or EC private key.")
    # Try to assume base64 body (DER PKCS8)
    try:
        der = base64.b64decode(s)
        key = load_der_private_key(der, password=None)
        if isinstance(key, ed25519.Ed25519PrivateKey):
            raw = key.private_bytes(Encoding.Raw, PrivateFormat.Raw, NoEncryption())
            return raw.hex()
        if isinstance(key, ec.EllipticCurvePrivateKey):
            d = key.private_numbers().private_value
            raw32 = d.to_bytes(32, byteorder="big", signed=False)
            return raw32.hex()
        raise ValueError("Unsupported DER key type. Provide Ed25519 or EC private key.")
    except Exception:
        pass
    raise ValueError("Unsupported private key format. Provide hex, PEM, or base64 PKCS8 body.")


def make_canister(canister_name: str, priv_key: str) -> Canister:
    try:
        priv_hex = _normalize_privkey_to_hex(priv_key)

        ic_identity = Identity(privkey=priv_hex)
        ic_agent = ICAgent(ic_identity, client)

        canister_id = os.getenv(f"CANISTER_ID_{canister_name.upper()}")
        candid = open(_get_candid_path(canister_name)).read()
        return Canister(agent=ic_agent, canister_id=canister_id, candid=candid)
    except Exception as e:
        print("Error making canister", e)
        raise e




