import os
import base64
import re
from dotenv import load_dotenv
from ic.canister import Canister
from ic.client import Client
from ic.identity import Identity
from ic.agent import Agent as ICAgent
from ic.principal import Principal
from cryptography.hazmat.primitives.serialization import load_pem_private_key, load_der_private_key, Encoding, PrivateFormat, NoEncryption
from cryptography.hazmat.primitives.asymmetric import ed25519, ec

load_dotenv()

BASE_URL = "http://localhost:4943" if os.getenv("DFX_NETWORK") == "local" else "https://ic0.app"

client = Client(url=BASE_URL)

def _get_candid_path(canister_name: str) -> str:
    # For wallet, prefer the source DID generated by build (kept freshest)
    if canister_name == "wallet":
        src_did = "../src/wallet/wallet.did"
        if os.path.isfile(src_did):
            return src_did
    # Otherwise, use declarations path if present (dfx generate)
    decl_path = f"../src/declarations/{canister_name}/{canister_name}.did"
    if os.path.isfile(decl_path):
        return decl_path
    # Fallback to source DID if exists for any other canister naming
    generic_src = f"../src/{canister_name}/{canister_name}.did"
    if os.path.isfile(generic_src):
        return generic_src
    # Default to declarations path (may raise later if missing)
    return decl_path


def _normalize_privkey_to_hex(priv_key: str) -> str:
    """Accept private key in forms of:
    - hex (direct)
    - PEM (with header) PKCS8
    - base64 body from PEM PKCS8 (without header)
    and return 32-byte hex (Ed25519 Raw).
    """
    s = (priv_key or "").strip()
    # If already a valid hex
    if re.fullmatch(r"[0-9a-fA-F]+", s) and len(s) % 2 == 0:
        return s.lower()
    # If the string contains a PEM header
    if "-----BEGIN" in s:
        key = load_pem_private_key(s.encode("utf-8"), password=None)
        # Ed25519 private key: export raw 32 bytes
        if isinstance(key, ed25519.Ed25519PrivateKey):
            raw = key.private_bytes(Encoding.Raw, PrivateFormat.Raw, NoEncryption())
            return raw.hex()
        # EC private key (e.g., "BEGIN EC PRIVATE KEY"): derive integer d then 32-byte big-endian
        if isinstance(key, ec.EllipticCurvePrivateKey):
            d = key.private_numbers().private_value
            # 32 bytes for P-256/secp256k1; pad as needed
            raw32 = d.to_bytes(32, byteorder="big", signed=False)
            return raw32.hex()
        # Other key types unsupported
        raise ValueError("Unsupported PEM key type. Provide Ed25519 or EC private key.")
    # Try to assume base64 body (DER PKCS8)
    try:
        der = base64.b64decode(s)
        key = load_der_private_key(der, password=None)
        if isinstance(key, ed25519.Ed25519PrivateKey):
            raw = key.private_bytes(Encoding.Raw, PrivateFormat.Raw, NoEncryption())
            return raw.hex()
        if isinstance(key, ec.EllipticCurvePrivateKey):
            d = key.private_numbers().private_value
            raw32 = d.to_bytes(32, byteorder="big", signed=False)
            return raw32.hex()
        raise ValueError("Unsupported DER key type. Provide Ed25519 or EC private key.")
    except Exception:
        pass
    raise ValueError("Unsupported private key format. Provide hex, PEM, or base64 PKCS8 body.")


def make_canister(canister_name: str, priv_key: str) -> Canister:
    try:
        priv_hex = _normalize_privkey_to_hex(priv_key)

        ic_identity = Identity(privkey=priv_hex)
        ic_agent = ICAgent(ic_identity, client)

        canister_id = os.getenv(f"CANISTER_ID_{canister_name.upper()}")
        candid = open(_get_candid_path(canister_name)).read()
        return Canister(agent=ic_agent, canister_id=canister_id, candid=candid)
    except Exception as e:
        print("Error making canister", e)
        raise e




from decimal import Decimal, getcontext
from typing import Union

# Increase precision for big integer to decimal division
getcontext().prec = 50

Numeric = Union[int, str, Decimal]


def _to_decimal(value: Numeric) -> Decimal:
    if isinstance(value, Decimal):
        return value
    if isinstance(value, int):
        return Decimal(value)
    if isinstance(value, str):
        # the string can be either a big integer or a decimal
        return Decimal(value)
    raise TypeError(f"Unsupported type for numeric conversion: {type(value)}")


def _format_decimal(value: Decimal, max_fraction_digits: int) -> str:
    # Limit to the maximum relevant decimal digits (avoid scientific notation)
    quant = Decimal(1).scaleb(-max_fraction_digits)  # 10^-max_fraction_digits
    q = value.quantize(quant)
    # Remove trailing zeros and the dot if not needed
    normalized = q.normalize()
    if normalized == 0:
        return "0"
    as_str = format(normalized, 'f')
    if '.' in as_str:
        as_str = as_str.rstrip('0').rstrip('.')
    return as_str


def wei_to_eth(wei: Numeric) -> str:
    d = _to_decimal(wei) / Decimal(10) ** 18
    return _format_decimal(d, 18)


def satoshi_to_btc(satoshi: Numeric) -> str:
    d = _to_decimal(satoshi) / Decimal(10) ** 8
    return _format_decimal(d, 8)


def lamports_to_sol(lamports: Numeric) -> str:
    d = _to_decimal(lamports) / Decimal(10) ** 9
    return _format_decimal(d, 9)


def e8s_to_icp(e8s: Numeric) -> str:
    d = _to_decimal(e8s) / Decimal(10) ** 8
    return _format_decimal(d, 8)

def to_amount(coin_symbol: str, smallest_unit_value: Numeric) -> str:
    """Convert value from smallest unit to human-readable amount.

    - BTC: satoshi -> BTC
    - ETH: wei -> ETH
    - SOL: lamports -> SOL
    """
    symbol = (coin_symbol or "").strip().upper()
    if symbol == "BTC":
        return satoshi_to_btc(smallest_unit_value)
    if symbol == "ETH":
        return wei_to_eth(smallest_unit_value)
    if symbol == "SOL":
        return lamports_to_sol(smallest_unit_value)
    if symbol == "ICP":
        return e8s_to_icp(smallest_unit_value)
    raise ValueError(f"Unsupported coin symbol: {coin_symbol}")


# ================= Reverse conversion: amount -> smallest unit =================

def eth_to_wei(amount: Numeric) -> int:
    d = _to_decimal(amount) * (Decimal(10) ** 18)
    # ensure integer (trunc toward zero)
    return int(d.to_integral_value(rounding=getcontext().rounding))


def btc_to_satoshi(amount: Numeric) -> int:
    d = _to_decimal(amount) * (Decimal(10) ** 8)
    return int(d.to_integral_value(rounding=getcontext().rounding))


def sol_to_lamports(amount: Numeric) -> int:
    d = _to_decimal(amount) * (Decimal(10) ** 9)
    return int(d.to_integral_value(rounding=getcontext().rounding))


def icp_to_e8s(amount: Numeric) -> int:
    d = _to_decimal(amount) * (Decimal(10) ** 8)
    return int(d.to_integral_value(rounding=getcontext().rounding))

def to_smallest(coin_symbol: str, amount: Numeric) -> int:
    """Convert human-readable amount to smallest unit (integer).

    - BTC: BTC -> satoshi
    - ETH: ETH -> wei
    - SOL: SOL -> lamports
    """
    symbol = (coin_symbol or "").strip().upper()
    if symbol == "BTC":
        return btc_to_satoshi(amount)
    if symbol == "ETH":
        return eth_to_wei(amount)
    if symbol == "SOL":
        return sol_to_lamports(amount)
    if symbol == "ICP":
        return icp_to_e8s(amount)
    raise ValueError(f"Unsupported coin symbol: {coin_symbol}")
from decimal import Decimal
from typing import Optional, Tuple
import requests


TOKENS_CONFIG = {
    "BTC": {"id": "bitcoin", "symbol": "BTC"},
    "ETH": {"id": "ethereum", "symbol": "ETH"},
    "SOL": {"id": "solana", "symbol": "SOL"},
}


def resolve_token_identifiers(raw_token: str) -> Tuple[Optional[str], Optional[str]]:
    """Resolve CoinGecko id and normalized symbol for a token.

    1) Use static mapping for common tokens (BTC/ETH/SOL)
    2) Otherwise, try CoinGecko search API to find an id by symbol/name
    3) Fallback to guessed id (lowercased, spaces->dashes) and uppercase symbol
    """
    if not raw_token:
        return None, None
    normalized = str(raw_token).strip()
    symbol = normalized.upper()
    guessed_id = normalized.lower().replace(" ", "-")

    mapped = TOKENS_CONFIG.get(symbol)
    if mapped:
        return mapped.get("id"), mapped.get("symbol")

    # Try CoinGecko search endpoint
    try:
        resp = requests.get(
            "https://api.coingecko.com/api/v3/search",
            params={"query": normalized},
            timeout=10,
        )
        resp.raise_for_status()
        data = resp.json()
        coins = data.get("coins", [])
        chosen = None
        for c in coins:
            if str(c.get("symbol", "")).upper() == symbol:
                chosen = c
                break
        if not chosen and coins:
            chosen = coins[0]
        if chosen:
            resolved_id = chosen.get("id") or guessed_id
            resolved_symbol = str(chosen.get("symbol", symbol)).upper()
            return resolved_id, resolved_symbol
    except Exception:
        pass

    return guessed_id, symbol


def _format_usd_dynamic(usd_value: Decimal) -> str:
    if usd_value >= Decimal("0.01"):
        return f"${usd_value.quantize(Decimal('0.01')):.2f}"

    small = format(usd_value, 'f')
    if '.' in small:
        integer_part, frac_part = small.split('.', 1)
        frac_part = frac_part[:20]
        small = integer_part + ('.' + frac_part if frac_part else '')
        small = small.rstrip('0').rstrip('.')
    if not small:
        small = "0.00"
    return f"${small}"


def get_price_usd(coin_type: str, amount_in_token: float, logger=None) -> str:
    # Validate amount
    try:
        if amount_in_token is None:
            return "$0.00"
        amount_num = Decimal(str(amount_in_token))
        if amount_num <= 0:
            return "$0.00"
    except Exception:
        return "$0.00"

    # Resolve identifiers for general token support
    token_id, token_symbol = resolve_token_identifiers(coin_type)
    if not token_id or not token_symbol:
        return "$0.00"

    # Build endpoints
    url_coingecko = f"https://api.coingecko.com/api/v3/simple/price?ids={token_id}&vs_currencies=usd"
    url_cryptocompare = f"https://min-api.cryptocompare.com/data/price?fsym={token_symbol}&tsyms=USD"

    price_usd: Optional[Decimal] = None

    # Try CoinGecko first
    try:
        resp = requests.get(url_coingecko, timeout=10)
        resp.raise_for_status()
        data = resp.json()
        if logger:
            logger.info(f"Data: {data}")
        value = data.get(token_id, {}).get("usd")
        if value is None:
            raise ValueError("CoinGecko returned no USD price for id")
        price_usd = Decimal(str(value))
    except Exception:
        try:
            resp = requests.get(url_cryptocompare, timeout=10)
            resp.raise_for_status()
            data = resp.json()
            value = data.get("USD")
            if value is None:
                return "$0.00"
            price_usd = Decimal(str(value))
        except Exception:
            return "$0.00"

    if price_usd is None or price_usd <= 0:
        return "$0.00"

    usd_value = amount_num * price_usd
    if usd_value <= 0:
        return "$0.00"

    return _format_usd_dynamic(usd_value)



def get_price_usd_number(coin_type: str):
    """Return the current price in USD for one unit of the given token.

    Returns Decimal or None on failure.
    """
    token_id, token_symbol = resolve_token_identifiers(coin_type)
    if not token_id or not token_symbol:
        return None

    url_coingecko = f"https://api.coingecko.com/api/v3/simple/price?ids={token_id}&vs_currencies=usd"
    url_cryptocompare = f"https://min-api.cryptocompare.com/data/price?fsym={token_symbol}&tsyms=USD"

    # Try CoinGecko first
    try:
        resp = requests.get(url_coingecko, timeout=10)
        resp.raise_for_status()
        data = resp.json()
        value = data.get(token_id, {}).get("usd")
        if value is None:
            raise ValueError("CoinGecko returned no USD price for id")
        price_usd = Decimal(str(value))
        if price_usd > 0:
            return price_usd
    except Exception:
        pass

    # Fallback to CryptoCompare
    try:
        resp = requests.get(url_cryptocompare, timeout=10)
        resp.raise_for_status()
        data = resp.json()
        value = data.get("USD")
        if value is None:
            return None
        price_usd = Decimal(str(value))
        if price_usd > 0:
            return price_usd
    except Exception:
        return None

    return None

import base64, hashlib, struct, zlib, re
from cryptography.hazmat.primitives.asymmetric import ed25519
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.serialization import load_pem_private_key, load_der_private_key, Encoding, PrivateFormat, NoEncryption
from ic.identity import Identity
from ic.principal import Principal

def text_encode_principal(principal_bytes: bytes) -> str:
    crc = zlib.crc32(principal_bytes) & 0xFFFFFFFF
    data = struct.pack(">I", crc) + principal_bytes  # CRC32 big-endian
    b32 = base64.b32encode(data).decode("ascii").lower().rstrip("=")
    return "-".join(b32[i:i+5] for i in range(0, len(b32), 5))

def principal_from_der_pubkey(der_pubkey: bytes) -> str:
    body = b"\x02" + hashlib.sha224(der_pubkey).digest()
    return text_encode_principal(body)

def _normalize_privkey_to_hex(priv_key: str) -> str:
    """Accept private key in forms of:
    - hex (direct)
    - PEM (with header) PKCS8
    - base64 body from PEM PKCS8 (without header)
    and return 32-byte hex (Ed25519 Raw).
    """
    s = (priv_key or "").strip()
    # If already a valid hex
    if re.fullmatch(r"[0-9a-fA-F]+", s) and len(s) % 2 == 0:
        return s.lower()
    # If the string contains a PEM header
    if "-----BEGIN" in s:
        key = load_pem_private_key(s.encode("utf-8"), password=None)
        raw = key.private_bytes(Encoding.Raw, PrivateFormat.Raw, NoEncryption())
        return raw.hex()
    # Try to assume base64 body (DER PKCS8)
    try:
        der = base64.b64decode(s)
        key = load_der_private_key(der, password=None)
        raw = key.private_bytes(Encoding.Raw, PrivateFormat.Raw, NoEncryption())
        return raw.hex()
    except Exception:
        pass
    raise ValueError("Unsupported private key format. Provide hex, PEM, or base64 PKCS8 body.")

def _normalize_privkey_to_hex(priv_key: str) -> str:
    """Accept private key in forms of:
    - hex (direct)
    - PEM (with header) PKCS8
    - base64 body from PEM PKCS8 (without header)
    and return 32-byte hex (Ed25519 Raw).
    """
    s = (priv_key or "").strip()
    # If already a valid hex
    if re.fullmatch(r"[0-9a-fA-F]+", s) and len(s) % 2 == 0:
        return s.lower()
    # If the string contains a PEM header
    if "-----BEGIN" in s:
        key = load_pem_private_key(s.encode("utf-8"), password=None)
        raw = key.private_bytes(Encoding.Raw, PrivateFormat.Raw, NoEncryption())
        return raw.hex()
    # Try to assume base64 body (DER PKCS8)
    try:
        der = base64.b64decode(s)
        key = load_der_private_key(der, password=None)
        raw = key.private_bytes(Encoding.Raw, PrivateFormat.Raw, NoEncryption())
        return raw.hex()
    except Exception:
        pass
    raise ValueError("Unsupported private key format. Provide hex, PEM, or base64 PKCS8 body.")

def generate_ed25519_identity():
    sk = ed25519.Ed25519PrivateKey.generate()

    priv_pem = sk.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption(),
    ).decode("utf-8")

    priv_b64 = "".join(l for l in priv_pem.splitlines() if not l.startswith("-----"))

    priv_hex = _normalize_privkey_to_hex(priv_b64)
    ic_identity = Identity(privkey=priv_hex)
    der_pubkey, _ = ic_identity.sign(b"probe")
    principal = Principal.self_authenticating(der_pubkey).to_str()
    der_pubkey_b64 = base64.b64encode(der_pubkey).decode("ascii")

    return principal, priv_b64, der_pubkey_b64

if __name__ == "__main__":
    ptxt, priv_pem, priv_b64, der_pub = generate_ed25519_identity()
    print("script principal:", ptxt)
def unwrap_candid(value):
    v = value
    # Unwrap list/tuple satu elemen berulang kali
    while isinstance(v, (list, tuple)) and len(v) == 1:
        v = v[0]
    # Unwrap Result
    if isinstance(v, dict):
        if "Ok" in v:
            return v["Ok"]
        if "Err" in v:
            raise Exception(f"Canister returned error: {v['Err']}")
    return v


from uagents import Context


def get_private_key_for_sender(ctx: Context):
    identities = ctx.storage.get("identity") or []
    if not isinstance(identities, list):
        identities = [identities]
    for item in identities:
        if isinstance(item, dict) and item.get("sender") == ctx.sender:
            return item.get("private_key")
    return None

def get_principal_for_sender(ctx: Context):
    identities = ctx.storage.get("identity") or []
    if not isinstance(identities, list):
        identities = [identities]
    for item in identities:
        if isinstance(item, dict) and item.get("sender") == ctx.sender:
            return item.get("principal")
    return None


import os
import hmac
import hashlib
import time
import json
from typing import Any, Dict

import requests

from config import STRIPE_API_KEY, STRIPE_API_URL, STRIPE_WEBHOOK_URL


def create_checkout_session(*, order_id: str, coin_type: str, amount_minor: int, destination_address: str, success_path: str = "/order/success", cancel_path: str = "/cancel") -> Dict[str, Any]:
    """Create a Stripe Checkout Session (one-time payment) in USD.

    amount_minor: integer amount in minor currency unit (e.g. cents)
    coin_type: e.g. BTC/ETH/SOL/ICP
    destination_address: the address to receive the tokens after payment (metadata)
    """
    headers = {
        "Authorization": f"Bearer {STRIPE_API_KEY}",
        "Content-Type": "application/x-www-form-urlencoded",
    }

    success_url = f"{STRIPE_WEBHOOK_URL}{success_path}?session_id={{CHECKOUT_SESSION_ID}}"
    cancel_url = f"{STRIPE_WEBHOOK_URL}{cancel_path}"

    # Send both session-level metadata and payment_intent metadata for redundancy
    payload = {
        "mode": "payment",
        "success_url": success_url,
        "cancel_url": cancel_url,
        # Stripe requires at least 30 minutes from creation
        "expires_at": str(int(time.time()) + 1800),
        # Session-level metadata
        "metadata[order_id]": order_id,
        "metadata[coin_type]": coin_type,
        "metadata[destination_address]": destination_address,
        "metadata[amount_minor]": str(amount_minor),
        # PaymentIntent metadata
        "payment_intent_data[metadata][order_id]": order_id,
        "payment_intent_data[metadata][coin_type]": coin_type,
        "payment_intent_data[metadata][destination_address]": destination_address,
        "payment_intent_data[metadata][amount_minor]": str(amount_minor),
        # Line item
        "line_items[0][price_data][currency]": "usd",
        "line_items[0][price_data][product_data][name]": f"Buy {coin_type.upper()} with the amount of {amount_minor}",
        "line_items[0][price_data][unit_amount]": str(amount_minor),
        "line_items[0][quantity]": "1",
    }

    print(f"[Stripe] Payload: {payload}")

    try:
        resp = requests.post(f"{STRIPE_API_URL}/checkout/sessions", headers=headers, data=payload)
    except Exception as e:
        print(f"[Stripe] Exception while creating checkout session: {e}")
        print(f"[Stripe] Payload (sanitized): {{'mode': '{payload.get('mode')}', 'amount_minor': '{payload.get('line_items[0][price_data][unit_amount]')}', 'coin_type': '{coin_type}', 'destination': '{destination_address[:12]}...'}}")
        raise

    if resp.status_code != 200:
        body_text = None
        try:
            body_text = resp.text
        except Exception:
            body_text = "<unreadable response body>"
        print("[Stripe] Checkout creation failed")
        print(f"[Stripe] Status: {resp.status_code}")
        print(f"[Stripe] Body: {body_text}")
        print(f"[Stripe] Payload (sanitized): {{'mode': '{payload.get('mode')}', 'amount_minor': '{payload.get('line_items[0][price_data][unit_amount]')}', 'coin_type': '{coin_type}', 'destination': '{destination_address[:12]}...'}}")
        # Raise an HTTPError similar to raise_for_status but with context
        raise requests.HTTPError(f"Stripe checkout creation failed: {resp.status_code} {body_text}", response=resp)

    return resp.json()


def _compute_signature(secret: str, payload: bytes, timestamp: str) -> str:
    signed_payload = f"{timestamp}.".encode("utf-8") + payload
    mac = hmac.new(secret.encode("utf-8"), msg=signed_payload, digestmod=hashlib.sha256)
    return mac.hexdigest()


def verify_webhook_signature(payload: bytes, sig_header: str, secret: str, tolerance: int = 300) -> bool:
    """Verify Stripe webhook signature without using stripe SDK.

    Stripe-Signature header format: t=timestamp,v1=signature[,v1=...]
    """
    try:
        items = dict(item.split("=", 1) for item in sig_header.split(","))
        timestamp = items.get("t")
        signatures = [v for k, v in items.items() if k == "v1"]
        if not timestamp or not signatures:
            return False
        expected_sig = _compute_signature(secret, payload, timestamp)
        if not any(hmac.compare_digest(s, expected_sig) for s in signatures):
            return False
        # Optional: timestamp tolerance
        if abs(int(time.time()) - int(timestamp)) > tolerance:
            return False
        return True
    except Exception:
        return False


def extract_checkout_metadata(event: Dict[str, Any]) -> Dict[str, Any]:
    """Extract metadata from checkout.session.completed event object.

    Returns dict with keys: order_id, coin_type, destination_address, amount_minor
    """
    obj = event.get("data", {}).get("object", {})
    metadata = obj.get("metadata", {}) or {}
    # Fallback to payment_intent metadata if present
    pi = obj.get("payment_intent")
    if isinstance(pi, dict):
        metadata = {**pi.get("metadata", {}), **metadata}
    return {
        "order_id": metadata.get("order_id"),
        "coin_type": metadata.get("coin_type"),
        "destination_address": metadata.get("destination_address"),
        "amount_minor": metadata.get("amount_minor"),
    }


